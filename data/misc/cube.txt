let math = require("math.txt");
let utils = require("utils.txt");

let vertexData = none;

let generateVertices = func() {

	let n = math.vector3(0,-1,0);
	let a = math.vector3(-1,-1,-1);
	let b = math.vector3(1,-1,-1);
	let c = math.vector3(1,-1,1);
	let d = math.vector3(-1,-1,1);

	let uv00 = math.vector2(0, 0);
	let uv10 = math.vector2(1, 0);
	let uv01 = math.vector2(0, 1);
	let uv11 = math.vector2(1, 1);

	let createVert = func(p, n, uv) {
		let res = {};
		res.pos = p;
		res.normal = n;
		res.uv = uv;

		res.flat = func() {
			let tmp = [];

			tmp.push(p[0]);
			tmp.push(p[1]);
			tmp.push(p[2]);
			tmp.push(1);

			tmp.push(n[0]);
			tmp.push(n[1]);
			tmp.push(n[2]);
			tmp.push(1);

			tmp.push(uv[0]);
			tmp.push(uv[1]);
			
			return tmp;
		};

		return res;
	};

	let face = [];
	face.push(createVert(a, n, uv00));
	face.push(createVert(b, n, uv10));
	face.push(createVert(c, n, uv11));

	face.push(createVert(a, n, uv00));
	face.push(createVert(c, n, uv11));
	face.push(createVert(d, n, uv01));

	let rotateFace = func(axis, angle) {
		let res = utils.map(face, func(v) {
			return createVert(
				math.rotateVector(v.pos, axis, angle),
				math.rotateVector(v.normal, axis, angle),
				v.uv
			);
		});

		return res;
	};

	let face2 = rotateFace(math.vector3(0, 0, 1), 90);
	let face3 = rotateFace(math.vector3(0, 0, 1), 180);
	let face4 = rotateFace(math.vector3(0, 0, 1), 270);
	
	let face5 = rotateFace(math.vector3(1, 0, 0), 90);
	let face6 = rotateFace(math.vector3(1, 0, 0), 270);

	let verticesArray = [];
	utils.foreach(face, func(v) {
		verticesArray.push(v);
	});

	utils.foreach(face2, func(v) {
		verticesArray.push(v);
	});

	utils.foreach(face3, func(v) {
		verticesArray.push(v);
	});

	utils.foreach(face4, func(v) {
		verticesArray.push(v);
	});

	utils.foreach(face5, func(v) {
		verticesArray.push(v);
	});

	utils.foreach(face6, func(v) {
		verticesArray.push(v);
	});

	let vertsFlat = utils.map(verticesArray, func(x) {
		return x.flat();
	});

	let nums = [];

	utils.foreach(vertsFlat, func(v) {
		utils.foreach(v, func(n) {
			if (n > -0.1 && n < 0.1) {
				n = 0;
			}
			nums.push(n);
		});
	});


	return nums;
};

let getVertexData = func() {
	if (vertexData == none) {
		vertexData = generateVertices();
	}
	return vertexData;
};

let heap = api.heap();
let uploadHeap = api.heap();

let buffer = api.buffer();
let uploadBuffer = api.buffer();

let createHeap = func(device, type, onReady) {
	let data = getVertexData();

	let width = 4 * data.length;

	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		onReady(h);
	});

	let h = api.heap();
	h.create(device, width, type);
	h.makeResident(fence, 1);
};

let copy = func(device, onReady) {
	let commandQueue = api.copyCommandQueue(device);

	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		uploadHeap = none;
		uploadBuffer = none;
		onReady();
	});

	let copyCL = api.copyCL();
	copyCL.create(device);
	copyCL.populate(buffer, uploadBuffer);
	copyCL.execute(commandQueue, fence, 1);
};

let loadCubeVertexBuffer = func(device, onReady) {
	let waiting = 2;

	let data = getVertexData();
	let size = 4 * data.length;
	let stride = 40;

	let callReady = func() {
		copy(device, func() {
			onReady(buffer);
		});
	};

	createHeap(device, "UPLOAD", func(h) {
		uploadHeap = h;
		uploadBuffer.init(size);
		uploadBuffer.setStride(stride);
		uploadBuffer.place(device, uploadHeap, 0, 0);
		uploadBuffer.copyData(data);

		waiting = waiting - 1;

		if (waiting == 0) {
			callReady();
		}
	});

	createHeap(device, "DEFAULT", func(h) {
		heap = h;
		buffer.init(size);
		buffer.setStride(stride);
		buffer.place(device, heap, 0, 0);

		waiting = waiting - 1;
		if (waiting == 0) {
			callReady();
		}
	});
};

export = loadCubeVertexBuffer;