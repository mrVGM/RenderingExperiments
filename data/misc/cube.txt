let math = require("math.txt");
let utils = require("utils.txt");

let vertexData = none;
let indexData = none;

let generateVertices = func() {
	let cube = api.primitives.cube();
	vertexData = cube.getVertices();
	indexData = cube.getIndices();
};

let getVertexData = func() {
	if (vertexData == none) {
		generateVertices();
	}
	return vertexData;
};

let getIndexData = func() {
	if (indexData == none) {
		generateIndices();
	}
	return indexData;
};

let heap = api.heap();
let indexHeap = api.heap();
let uploadHeap = api.heap();
let indexUploadHeap = api.heap();

let buffer = api.buffer();
let uploadBuffer = api.buffer();
let indexBuffer = api.buffer();
let indexUploadBuffer = api.buffer();

let createHeap = func(device, type, data, onReady) {
	let width = 4 * data.length;

	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		onReady(h);
	});

	let h = api.heap();
	h.create(device, width, type);
	h.makeResident(fence, 1);
};

let copy = func(device, onReady) {

	let commandQueue = api.copyCommandQueue();
	commandQueue.create(device);

	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 2, func(arg) {
		uploadHeap = none;
		uploadBuffer = none;
		onReady();
	});

	let copyCL = api.copyCL();
	copyCL.create(device);
	copyCL.populate(buffer, uploadBuffer);
	copyCL.execute(commandQueue, fence, 1);

	let copyCL2 = api.copyCL();
	copyCL2.create(device);
	copyCL2.populate(indexBuffer, indexUploadBuffer);
	copyCL2.execute(commandQueue, fence, 2);
};

let loadCubeVertexBuffer = func(device, onReady) {
	let waiting = 4;

	let data = getVertexData();
	let size = 4 * data.length;
	let stride = 32;

	let indexData = getIndexData();
	let indexSize = 4 * indexData.length;

	let callReady = func() {
		copy(device, func() {
			onReady(buffer, indexBuffer);
		});
	};

	createHeap(device, "UPLOAD", vertexData, func(h) {
		uploadHeap = h;
		uploadBuffer.init(size);
		uploadBuffer.setStride(stride);
		uploadBuffer.place(device, uploadHeap, 0, 0);
		uploadBuffer.copyData(data);

		waiting = waiting - 1;

		if (waiting == 0) {
			callReady();
		}
	});

	createHeap(device, "DEFAULT", vertexData, func(h) {
		heap = h;
		buffer.init(size);
		buffer.setStride(stride);
		buffer.place(device, heap, 0, 0);

		waiting = waiting - 1;
		if (waiting == 0) {
			callReady();
		}
	});


	createHeap(device, "UPLOAD", indexData, func(h) {
		indexUploadHeap = h;
		indexUploadBuffer.init(indexSize);
		indexUploadBuffer.setStride(4);
		indexUploadBuffer.place(device, indexUploadHeap, 0, 0);
		indexUploadBuffer.copyIntData(indexData);

		waiting = waiting - 1;

		if (waiting == 0) {
			callReady();
		}
	});

	createHeap(device, "DEFAULT", indexData, func(h) {
		indexHeap = h;
		indexBuffer.init(indexSize);
		indexBuffer.setStride(4);
		indexBuffer.place(device, indexHeap, 0, 0);

		waiting = waiting - 1;
		if (waiting == 0) {
			callReady();
		}
	});
};

export = loadCubeVertexBuffer;