let math = require("math.txt");
let utils = require("utils.txt");

let wnd = api.window();
wnd.create(600, 400);

let dragCrt = func() {
	if (wnd.isAlive() == 0) {
		print("Window closed!");
		wnd = none;
		return;
	}
	wnd.drag();
	timeout(dragCrt, 0);
};
dragCrt();

let device = api.device();
let swapChain = api.swapChain();
let commandQueue = api.commandQueue();

let generalInit = func() {
	device.create();
	commandQueue.create(device);
	swapChain.create(device, wnd, commandQueue);
	print("General Init!");
};

let rend3D = none;
let cam = api.aux.camera();
let offset = 0;

let updateCam = func() {
	offset = offset + 0.01;

	let pos = math.vector3(5 * math.cos(offset), 0, 5 * math.sin(offset));
	let target = math.vector3(0, 0, 0);

	let aspect = wnd.width() / wnd.height();
	cam.setPosition(pos);
	cam.setTarget(target);
	cam.setAspect(aspect);
	cam.setNearPlane(0.1);
	cam.setFarPlane(10000);
	cam.setFOV(60);

	let mat = cam.getMVPMatrix();

	rend3D.constBuff.copyData(mat);
};

let updateCamSafe = func() {
	try {
		updateCam();
	} catch(e) {
		print(e);
	}
};

let startRender3D = func(vertexBuff, indexBuff, instanceBuff) {
	let render3DCL = require("displayCube.txt");
	render3DCL(device, func(rend) {
		rend3D = rend;
		rend3D.startRender(wnd, swapChain, commandQueue, vertexBuff, indexBuff, instanceBuff, updateCamSafe);
	});
};

let cube = require("primitives/cube.txt");
let cubeVerts = none;
let instance = none;
let resources = require("resources/resourceUtils.txt");

let render2Cubes = func() {
	let tryRend = func() {
		if (cubeVerts == none || instance == none) {
			return;
		}

		startRender3D(cubeVerts.vertex, cubeVerts.index, instance);
	};

	cube(device, func(verts) {
		cubeVerts = verts;
		tryRend();
	});

	let instanceData = [];
	instanceData.push(0);
	instanceData.push(1);
	instanceData.push(0);
	instanceData.push(math.cos(math.PI / 8));
	instanceData.push(-math.sin(math.PI / 8));
	instanceData.push(0);
	instanceData.push(0);
	instanceData.push(1);
	instanceData.push(1);
	instanceData.push(1);

	instanceData.push(0);
	instanceData.push(-1);
	instanceData.push(0);
	instanceData.push(math.cos(math.PI / 8));
	instanceData.push(-math.sin(math.PI / 8));
	instanceData.push(0);
	instanceData.push(0);
	instanceData.push(1);
	instanceData.push(1);
	instanceData.push(1);

	let instanceBB = resources.bufferBuilder();
	instanceBB.upload(1);
	instanceBB.setSize(4 * instanceData.length);
	instanceBB.setStride(40);
	instanceBB.build(device, func(buff) {
		instance = buff;
		instance.copyData(instanceData);

		tryRend();
	});
};

let gBuffer = none;
let litPass = api.deferred.litPass();

let renderPlain = func() {
	let fence = api.fence();
	fence.create(device);

	let index = 1;

	let plain = require("displayPlain.txt");
	let rendFunc = none;

	let render = func() {
		if (wnd.isAlive() == 0) {
			return;
		}

		let fe = api.fenceEvent();
		fe.create();

		fe.wait(fence, index, func(arg) {
			index = index + 1;

			swapChain.present();
			render();
		});

		swapChain.updateCurrentFrameIndex();
		litPass.executeStart(commandQueue, fence, 0);
		rendFunc();
		litPass.populateEnd(swapChain, gBuffer);
		litPass.executeEnd(commandQueue, fence, index);
	};

	plain(device, swapChain, commandQueue, gBuffer, func(rendCreator) {
		rendFunc = rendCreator(func() {
			let a = 5;
		});
		render();
	});
};

let camBuff = none;
let getCamBuff = func(onReady) {
	if (camBuff != none) {
		onReady(camBuff);
		return;
	}

	let camBB = resources.bufferBuilder();
	camBB.upload(1);
	camBB.setSize(256);
	camBB.setStride(256);
	camBB.build(device, func(buff) {
		camBuff = buff;
		onReady(camBuff);
	});
};

let prepMaterial = func(onReady) {
	let camera = none;

	let callReady = func() {
		if (camera == none || cubeVerts == none) {
			return;
		}

		let createMaterial = require("materials/litMaterial.txt");
		let material = createMaterial(device, "cube.hlsl", camera, gBuffer);

		onReady(material);
	};

	getCamBuff(func(cam) {
		camera = cam;
		callReady();
	});

	cube(device, func(verts) {
		cubeVerts = verts;
		callReady();
	});
};

try {
	generalInit();
	#render2Cubes();

	let loadGBuff = require("gBuffer.txt");
	loadGBuff(device, wnd.width(), wnd.height(), func(gBuff) {
		gBuffer = gBuff;

		litPass.setupStartCL(device, gBuffer);
		litPass.setupEndCL(device, gBuffer);

		prepMaterial(func(mat) {
			print(mat);
		});

		renderPlain();
	});

} catch(e) {
	print(e);
}
