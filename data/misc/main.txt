let math = require("math.txt");
let utils = require("utils.txt");

let wnd = api.window();
wnd.create(600, 400);

let dragCrt = func() {
	if (wnd.isAlive() == 0) {
		print("Window closed!");
		wnd = none;
		return;
	}
	wnd.drag();
	timeout(dragCrt, 0);
};
dragCrt();

let device = api.device();
let swapChain = api.swapChain();
let commandQueue = api.commandQueue();

let generalInit = func() {
	device.create();
	commandQueue.create(device);
	swapChain.create(device, wnd, commandQueue);
	print("General Init!");
};

let cam = api.aux.camera();
let offset = 0;

let updateCam = func(camBuff) {
	offset = offset + 0.01;

	let pos = math.vector3(5 * math.cos(offset), offset, 5 * math.sin(offset));
	let target = math.vector3(0, 0, 0);

	let aspect = wnd.width() / wnd.height();
	cam.setPosition(pos);
	cam.setTarget(target);
	cam.setAspect(aspect);
	cam.setNearPlane(0.1);
	cam.setFarPlane(10000);
	cam.setFOV(60);

	let camData = cam.getMVPMatrix();
	utils.foreach(pos, func(x) {
		camData.push(x);
	});

	camBuff.copyData(camData);
};

let resources = require("resources/resourceUtils.txt");

let gBuffer = none;
let litPass = api.deferred.litPass();

let prepMaterial = func() {
	let createMaterial = require("materials/litMaterial.txt");
	let material = createMaterial(device, "cube.hlsl", gBuffer);
	return material;
};

let theMaterial = none;

let startRendMat = func() {
	print("start render mat");

	let fence = api.fence();
	fence.create(device);

	let index = 1;

	let render = func() {
		if (wnd.isAlive() == 0) {
			return;
		}

		let fe = api.fenceEvent();
		fe.create();

		fe.wait(fence, index, func(arg) {
			index = index + 1;

			swapChain.present();
			render();
		});

		swapChain.updateCurrentFrameIndex();
		litPass.executeStart(commandQueue, fence, 0);

		let objects = scene.getObjects();

		utils.foreach(objects, func(x) {
			theMaterial.setObject(x.geometry);
			theMaterial.setInstanceBuffer(x.instances);
			theMaterial.render(swapChain, commandQueue);
		});
		updateCam(gBuffer.camBuffer);


		litPass.populateEnd(swapChain, gBuffer, scene.lightsBuff, scene.lightsConstantBuff);
		litPass.executeEnd(commandQueue, fence, index);
	};

	render();
};

let scene = require("scene/scene.txt");

try {
	generalInit();

	let loadGBuff = require("gBuffer.txt");

	scene.addObject(math.vector3(0,0,0), math.vector(1,0,0,0), math.vector3(1,1,1));
	scene.addLight(math.vector3(0,5,0), math.vector3(1,1,1), 10);
	scene.addLight(math.vector3(5,0,0), math.vector3(1,1,1), 10);
	let sceneLoaded = 0;

	scene.load(device, func() {
		sceneLoaded = 1;
	});

	let getMat = func() {
		if (gBuffer == none || sceneLoaded == 0) {
			return;
		}
		updateCam(gBuffer.camBuffer);
		theMaterial = prepMaterial();

		startRendMat();
	};

	loadGBuff(device, wnd.width(), wnd.height(), func(gBuff) {
		gBuffer = gBuff;

		litPass.setupStartCL(device, gBuffer);
		litPass.setupEndCL(device, gBuffer);

		print("GBuffer set up!");
		getMat();
	});

} catch(e) {
	print(e);
}
