let vertexData = [];
vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);
vertexData.push(1);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(1);
vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);

let vertexDataLoaded = 0;
let vertexHeap = api.heap();
let vertexBuff = api.buffer();

let dataLoadRequested = 0;
let cachedCB = [];

let loadVertexData = func(device, onVertexDataLoaded) {
	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		print("#Vertex Heap Loaded!");

		vertexBuff.init(96);
		vertexBuff.place(device, vertexHeap, 0, 0);
		vertexBuff.copyData(vertexData);
		print("#Vertex Buffer Loaded!");

		onVertexDataLoaded();
	});

	vertexHeap.create(device, 96, "UPLOAD");
	print("#Vertex Heap Created!");
	vertexHeap.makeResident(fence, 1);
};

let loadData = func(device, onReady) {
	let heap = none;
	let buff = none;

	if (vertexDataLoaded) {
		onReady(heap, buff);
		return;
	}

	if (dataLoadRequested) {
		cachedCB.push(onReady);
		return;
	}

	dataLoadRequested = 1;

	loadVertexData(device, func() {
		vertexDataLoaded = 1;
		onReady(heap, buff);

		print(cachedCB.length);
		let i = 0;
		while (i < cachedCB.length) {
			let curCB = cachedCB[i];
			curCB(heap, buff);
			i = i + 1;
		}
	});
};

let createCanvas = func(device, vertexShader, pixelShader, overrideBuff, onReady) {

	loadData(device, func(heap, pBuff) {
		let buff = pBuff;
		if (overrideBuff != none) {
			buff = overrideBuff;
		}

		let res = {};
		res.heap = heap;
		res.constantBuff = buff;
		res.vertexBuff = vertexBuff;

		let canvasCL = api.canvasCL();
		canvasCL.create(device, vertexShader, pixelShader, vertexBuff, 16);
		res.commandList = canvasCL;

		res.render = func(swapChain, commandQueue, fence, frame, onReady) {
			let fe = api.fenceEvent();
			fe.create();
			fe.wait(fence, frame, func(arg) {
				onReady();
			});

			canvasCL.populate(swapChain);
			canvasCL.execute(commandQueue, fence, frame);
		};

		print("#ready");
		onReady(res);
	});
};


export = createCanvas;