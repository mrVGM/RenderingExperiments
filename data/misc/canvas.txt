let vertexData = [];
vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);
vertexData.push(1);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(1);
vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);

let vertexDataLoaded = 0;
let vertexHeap = api.heap();
let vertexBuff = api.buffer();

let loadVertexData = func(device, onVertexDataLoaded) {
	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		print("#Vertex Heap Loaded!");

		vertexBuff.init(96);
		vertexBuff.place(device, vertexHeap, 0, 0);
		vertexBuff.copyData(vertexData);
		print("#Vertex Buffer Loaded!");

		onVertexDataLoaded();
	});

	vertexHeap.create(device, 96, "UPLOAD");
	print("#Vertex Heap Created!");
	vertexHeap.makeResident(fence, 1);
};

let loadConstantData = func(device, onConstantDataLoaded) {
	let fence = api.fence();
	fence.create(device);
	let constantBuff = api.buffer();
	let constantHeap = api.heap();
	
	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		print("#Constant Heap Loaded!");

		let cbData = [];
		let index = 0;
		while (index < 256) {
			cbData.push(0);
			index = index + 1;
		}
		cbData[2] = 0.5;
		cbData[3] = 0.5;

		constantBuff.init(256);
		constantBuff.place(device, constantHeap, 0, 0);
		constantBuff.copyData(cbData);
		print("#Constant Buffer Loaded!");
		onConstantDataLoaded(constantHeap, constantBuff);
	});

	constantHeap.create(device, 256, "UPLOAD");
	print("#Constant Heap Created!");

	constantHeap.makeResident(fence, 1);
};


let loadData = func(device, onReady) {
	let waiting = 1;
	let heap = none;
	let buff = none;

	if (vertexDataLoaded == 0) {
		waiting = 2;
		vertexDataLoaded = 1;

		loadVertexData(device, func() {
			waiting = waiting - 1;
			if (waiting == 0) {
				onReady(heap, buff);
			}
		});
	}

	loadConstantData(device, func(cHeap, cBuff) {
		heap = cHeap;
		buff = cBuff;

		waiting = waiting - 1;
		if (waiting == 0) {
			onReady(heap, buff);
		}
	});
};

let createCanvas = func(device, vertexShader, pixelShader, overrideBuff, onReady) {

	loadData(device, func(heap, pBuff) {
		let buff = pBuff;
		if (overrideBuff != none) {
			buff = overrideBuff;
		}

		let res = {};
		res.heap = heap;
		res.constantBuff = buff;
		res.vertexBuff = vertexBuff;

		let canvasCL = api.canvasCL();
		canvasCL.create(device, vertexShader, pixelShader, vertexBuff, 16);
		res.commandList = canvasCL;

		let cbDescriptorHeap = api.descriptorHeap();
		let cBuffs = [];

		let buffDesc = {};
		buffDesc.type = "cbv";
		buffDesc.buffer = buff;

		cBuffs.push(buffDesc);
		cbDescriptorHeap.create(device, cBuffs);
		res.descriptorHeap = cbDescriptorHeap;

		res.render = func(swapChain, commandQueue, fence, frame, onReady) {
			let fe = api.fenceEvent();
			fe.create();
			fe.wait(fence, frame, func(arg) {
				onReady();
			});

			canvasCL.populate(swapChain, cbDescriptorHeap);
			canvasCL.execute(commandQueue, fence, frame);
		};

		print("#ready");
		onReady(res);
	});
};


export = createCanvas;