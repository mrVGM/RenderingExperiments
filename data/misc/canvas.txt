let vertexData = [];
vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);
vertexData.push(1);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(1);
vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);

let vertexDataLoaded = 0;
let vertexHeap = api.heap();
let vertexBuff = api.buffer();

let dataLoadRequested = 0;
let cachedCB = [];

let loadVertexData = func(device, onVertexDataLoaded) {
	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		print("#Vertex Heap Loaded!");

		vertexBuff.init(96);
		vertexBuff.place(device, vertexHeap, 0, 0);
		vertexBuff.copyData(vertexData);
		print("#Vertex Buffer Loaded!");

		onVertexDataLoaded();
	});

	vertexHeap.create(device, 96, "UPLOAD");
	print("#Vertex Heap Created!");
	vertexHeap.makeResident(fence, 1);
};

let loadData = func(device, onReady) {
	if (vertexDataLoaded) {
		onReady();
		return;
	}

	if (dataLoadRequested) {
		cachedCB.push(onReady);
		return;
	}

	dataLoadRequested = 1;

	loadVertexData(device, func() {
		vertexDataLoaded = 1;
		onReady();

		let i = 0;
		while (i < cachedCB.length) {
			let curCB = cachedCB[i];
			curCB();
			i = i + 1;
		}
	});
};

let createCanvas = func(device, vertexShader, pixelShader, onReady) {

	loadData(device, func() {
		let res = {};
		let canvasCL = api.canvasCL();
		canvasCL.create(device, vertexShader, pixelShader, vertexBuff, 16);
		res.commandList = canvasCL;

		print("#ready");
		onReady(res);
	});
};


export = createCanvas;