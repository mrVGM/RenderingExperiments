let renderer = api.renderCanvasesCL();
let myFence = api.fence();
let myFrame = 0;

let cnvs = [];

let obj = {};

let create = func(device) {
	renderer.create(device);
	myFence.create(device);
};
let populate = func(swapChain) {
	renderer.populate(swapChain);

	let i = 0;
	while (i < cnvs.length) {
		let cur = cnvs[i];
		i = i + 1;
		cur.commandList.populate(swapChain);
	}
};
let execute = func(commandQueue, fence, frame) {
	let tmp = [];
	let i = 0;
	while (i < cnvs.length) {
		let cur = cnvs[i];
		i = i + 1;
		tmp.push(cur.commandList);
	}
	renderer.execute(commandQueue, fence, frame, tmp);
};
let addCanvas = func(canvas) {
	cnvs.push(canvas);
};

let render = func(commandQueue, swapChain, onReady) {
	populate(swapChain);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(myFence, myFrame, func(arg) {
		myFrame = myFrame + 1;
		onReady();
	});

	execute(commandQueue, myFence, myFrame);
};

obj.create = create;
obj.populate = populate;
obj.execute = execute;
obj.addCanvas = addCanvas;
obj.render = render;

export = obj;