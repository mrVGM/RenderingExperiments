let renderer = api.renderCanvasesCL();
let myFence = api.fence();
let myFrame = 0;

let cnvs = [];
let texDescHeap = api.descriptorHeap();

let texInit = func(device, commandQueue, tex, onReady) {
	let fence = api.fence();
	fence.create(device);

	let updateFE = api.fenceEvent();
	updateFE.create();
	updateFE.wait(fence, 1, func(arg) {
		let tmp = {};
		tmp.type = "srv_tex";
		tmp.texture = tex;

		let l = [];
		l.push(tmp);
		texDescHeap.create(device, l);

		onReady();
	});

	let updateCL = api.updateTextureCL();
	updateCL.create(device);
	updateCL.populate(device, tex);
	updateCL.execute(commandQueue, fence, 1);
};


let obj = {};

let create = func(device) {
	renderer.create(device);
	myFence.create(device);
};

let populate = func(swapChain) {
	renderer.populate(swapChain);

	let i = 0;
	while (i < cnvs.length) {
		let cur = cnvs[i];
		i = i + 1;
		cur.commandList.populate(swapChain, texDescHeap);
	}
};
let execute = func(commandQueue, fence, frame) {
	let tmp = [];
	let i = 0;
	while (i < cnvs.length) {
		let cur = cnvs[i];
		i = i + 1;
		tmp.push(cur.commandList);
	}
	renderer.execute(commandQueue, fence, frame, tmp);
};
let addCanvas = func(canvas) {
	cnvs.push(canvas);
};

let render = func(commandQueue, swapChain, onReady) {
	populate(swapChain);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(myFence, myFrame, func(arg) {
		myFrame = myFrame + 1;
		onReady();
	});

	execute(commandQueue, myFence, myFrame);
};

obj.create = create;
obj.populate = populate;
obj.execute = execute;
obj.addCanvas = addCanvas;
obj.render = render;
obj.texInit = texInit;

export = obj;