let loadBuff = func(device, onReady) {
	let fence = api.fence();
	fence.create(device);
	
	let buff = api.buffer();
	let heap = api.heap();

	let initBuffer = func() {
		print("$Heap Loaded!");

		let cbData = [];
		let index = 0;
		while (index < 256) {
			cbData.push(0);
			index = index + 1;
		}

		buff.init(256);
		buff.setStride(16);
		buff.place(device, heap, 0);
		buff.copyData(cbData);

		print("$Buffer Loaded!");
		onReady(heap, buff);
	};

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		try {
			initBuffer();
		} catch(e) {
			print(e);
		}
	});

	heap.create(device, 256, "UPLOAD");
	print("$Heap Created!");
	heap.makeResident(fence, 1);
};

let compileShader = func() {
	let shaderCode = readFile("compute.hlsl");
	let computeShader = api.computeShader();
	computeShader.compile(shaderCode);
	return computeShader;
};


let init = func(device, onReady) {
	let computeCommandQueue = api.computeCommandQueue();
	computeCommandQueue.create(device);
	let shader = compileShader();
	let computeCL = api.computeCL();
	computeCL.create(device, shader);

	let waiting = 3;

	let srvHeap = none;
	let srvBuff = none;
	let cbHeap = none;
	let cBuff = none;
	let uavHeap = none;
	let uavBuff = none;

	let createDescHeap = func() {
		let descHeap = api.descriptorHeap();
		
		let buffs = [];
		let srvDesc = {};
		srvDesc.type = "srv";
		srvDesc.buffer = srvBuff;
		buffs.push(srvDesc);

		let uavDesc = {};
		uavDesc.type = "uav";
		uavDesc.buffer = uavBuff;
		buffs.push(uavDesc);

		descHeap.create(device, buffs);

		return descHeap;
	};

	let callReady = func() {
		let res = {};
		res.srvHeap = srvHeap;
		res.srvBuff = srvBuff;
		res.cbHeap = cbHeap;
		res.cBuff = cBuff;
		res.uavHeap = uavHeap;
		res.uavBuff = uavBuff;

		res.commandQueue = computeCommandQueue;
		res.commandList = computeCL;
		res.descHeap = createDescHeap();

		res.dispatch = func() {
			print("Dispatch!");
#			computeCL.populate(res.descHeap, cBuff, 1, 1, 1);
#
#			let fence = api.fence();
#			fence.create(device);
#			let fe = api.fenceEvent();
#			fe.create();
#			fe.wait(fence, 1, func(arg) {
#				print("Computation Done!");
#			});
#
#			#computeCL.execute(computeCommandQueue, fence, 1);
		};

		onReady(res);
	};

	loadBuff(device, func(heap, buff) {
		waiting = waiting - 1;
		srvHeap = heap;
		srvBuff = buff;

		if (waiting == 0) {
			callReady();
		}
	});

	loadBuff(device, func(heap, buff) {
		waiting = waiting - 1;
		cbHeap = heap;
		cBuff = buff;

		if (waiting == 0) {
			callReady();
		}
	});

	loadBuff(device, func(heap, buff) {
		waiting = waiting - 1;
		uavHeap = heap;
		uavBuff = buff;

		if (waiting == 0) {
			callReady();
		}
	});
};

export = init;