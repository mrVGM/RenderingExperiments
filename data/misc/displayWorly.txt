let vertexData = [];
vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);
vertexData.push(1);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(-1);
vertexData.push(-1);
vertexData.push(0);
vertexData.push(0);

vertexData.push(1);
vertexData.push(1);
vertexData.push(1);
vertexData.push(1);

vertexData.push(1);
vertexData.push(-1);
vertexData.push(1);
vertexData.push(0);

let vertexHeap = api.heap();
let vertexBuff = api.buffer();

let constHeap = api.heap();
let constBuff = api.buffer();

let inUse = 0;

let loadVertexData = func(device, onReady) {
	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		vertexBuff.init(96);
		vertexBuff.place(device, vertexHeap, 0, 0);
		vertexBuff.copyData(vertexData);

		onReady();
	});

	vertexHeap.create(device, 96, "UPLOAD");
	vertexHeap.makeResident(fence, 1);
};

let loadConstData = func(device, onReady) {
	let fence = api.fence();
	fence.create(device);

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		constBuff.init(256);
		constBuff.place(device, constHeap, 0, 0);
		onReady();
	});

	constHeap.create(device, 256, "UPLOAD");
	constHeap.makeResident(fence, 1);
};

let loadData = func(device, onReady) {
	let waiting = 2;

	loadVertexData(device, func() {
		waiting = waiting - 1;
		if (waiting == 0) {
			onReady();
		}
	});

	loadConstData(device, func() {
		waiting = waiting - 1;
		if (waiting == 0) {
			onReady();
		}
	});
};

let requestRenderer = func(device, onReady) {
	if (inUse) {
		thow("Renderer already in use!");
	}
	inUse = 1;

	let compileShaders = func() {
		let shaderCode = readFile("shaders.hlsl");

		let vertexShader = api.vertexShader();
		vertexShader.compile(shaderCode);

		let pixelShader = api.pixelShader();
		pixelShader.compile(shaderCode);

		let res = {};
		res.vs = vertexShader;
		res.ps = pixelShader;

		return res;
	};

	let startRender = func(wnd, swapChain, commandQueue, worlyData) {

		let shaders = compileShaders();

		let displayWorlyCL = api.worly.displayWorly();
		displayWorlyCL.create(device, shaders.vs, shaders.ps, constBuff, vertexBuff, 16);

		let descriptors = [];
		let texDesc = {};
		texDesc.type = "srv_tex";
		texDesc.texture = worlyData.getUAVTex();

		descriptors.push(texDesc);

		let descHeap = api.descriptorHeap();
		descHeap.create(device, descriptors);

		let frame = 0;

		let fence = api.fence();
		fence.create(device);

		let render = func() {
			let renderImpl = func() {
				if (wnd.isAlive() == 0) {
					return;
				}

				let renderFE = api.fenceEvent();
				renderFE.create();

				renderFE.wait(fence, frame, func(arg) {
					swapChain.present();	
					frame = frame + 1;
					render();
				});

				swapChain.updateCurrentFrameIndex();
				displayWorlyCL.populate(swapChain, descHeap);
				displayWorlyCL.execute(commandQueue, fence, frame);
			};

			try {
				renderImpl();
			} catch(e) {
				print(e);
			}
		};

		render();
	};

	loadData(device, func() {
		let res = {};
		res.startRender = startRender;
		res.constBuff = constBuff;
		onReady(res);
	});
};

export = requestRenderer;