let utils = require("utils.txt");

let loadCB = func(device, onReady) {
	let fence = api.fence();
	fence.create(device);
	
	let buffSize = 256;
	let buff = api.buffer();
	let heap = api.heap();

	let initBuffer = func() {
		buff.init(buffSize);
		buff.place(device, heap, 0, 0);
		
		onReady(buff);
	};

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		try {
			initBuffer();
		} catch(e) {
			print(e);
		}
	});

	let heapType = "UPLOAD";
	heap.create(device, buffSize, heapType);
	heap.makeResident(fence, 1);
};

let loadSRVBuff = func(device, buffSize, buffStride, onReady) {
	let fence = api.fence();
	fence.create(device);

	let buff = api.buffer();
	let heap = api.heap();

	let initBuffer = func() {
		buff.init(buffSize);
		buff.setStride(buffStride);
		buff.place(device, heap, 0, 0);
		
		onReady(buff);
	};

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		try {
			initBuffer();
		} catch(e) {
			print(e);
		}
	});

	let heapType = "UPLOAD";
	heap.create(device, buffSize, heapType);
	heap.makeResident(fence, 1);
};

let loadSRVBuffs = func(device, buffSizes, buffStride, onReady) {

	let buffs = [];
	utils.foreach(buffSizes, func(x) {
		buffs.push(none);
	});

	let waiting = buffs.length;

	let callReady = func() {
		if (waiting == 0) {
			onReady(buffs);
		}
	};

	let loadSingle = func(k) {
		let s = buffSizes[k];

		loadSRVBuff(device, s, buffStride, func(buff) {
			buffs[k] = buff;
			waiting = waiting - 1;
			callReady();
		});
	};

	let index = 0;
	utils.foreach(buffs, func(x) {
		loadSingle(index);
		index = index + 1;
	});
};




let loadTex = func(device, texSize, onReady) {
	let fence = api.fence();
	fence.create(device);
	
	let tex = api.texture();
	tex.init3D(texSize, texSize, texSize, 1);

	let heap = api.heap();

	let placeTex = func() {
		tex.place(device, heap, 0);
		onReady(tex);
	};

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		try {
			placeTex();
		} catch(e) {
			print(e);
		}
	});

	heap.create(device, tex.getAllocationSize(device), "DEFAULT");
	heap.makeResident(fence, 1);
};

let compileShader = func() {
	let shaderCode = readFile("compute.hlsl");
	let computeShader = api.computeShader();
	computeShader.compile(shaderCode);
	return computeShader;
};

let execute = func(compute, device, data, graphicsCommandQueue, onReady) {

	compute.create(device, data.shader);
	compute.populate(data.getConstantBuff(), data.getUAVTex(), data.descHeap, data.texSize / 16, data.texSize / 16, data.texSize / 4);

	let fence = api.fence();
	fence.create(device);

	let prepareForGraphics = func() {
		let prepFE = api.fenceEvent();
		prepFE.create();
		prepFE.wait(fence, 2, func(arg) {
			onReady();
		});
		compute.executePrepareForPS(graphicsCommandQueue, fence, 2);
	};

	let computeFE = api.fenceEvent();
	computeFE.create();
	computeFE.wait(fence, 1, func(arg) {
		try {
			prepareForGraphics();
		} catch(e) {
			print(e);
		}
	});

	let computeCommandQueue = api.computeCommandQueue();
	computeCommandQueue.create(device);
	compute.executeCompute(computeCommandQueue, fence, 1);
};

let prepareData = func(device, texSize, onReady) {
	let compute = api.worly.textureCompute();
	let srvBuffSize = compute.getSRVBufferSize();
	let srvBuffStride = compute.getSRVBufferStride();

	let waiting = 3;
	let srvBuff = none;
	let cBuff = none;
	let uavTex = none;

	let createDescHeap = func() {
		let descHeap = api.descriptorHeap();
		
		let buffs = [];
		let uavDesc = {};
		uavDesc.type = "uav_tex";
		uavDesc.texture = uavTex;
		buffs.push(uavDesc);

		utils.foreach(srvBuff, func(x) {
			let srvDesc = {};
			srvDesc.type = "srv_buff";
			srvDesc.buffer = x;
			buffs.push(srvDesc);
		});

		descHeap.create(device, buffs);

		return descHeap;
	};

	let callReady = func() {
		let res = {};
		res.descHeap = createDescHeap();

		res.getConstantBuff = func() {
			return cBuff;
		};
		res.getSRVBuff = func() {
			return srvBuff;
		};
		res.getUAVTex = func() {
			return uavTex;
		};

		res.shader = compileShader();
		res.texSize = texSize;

		res.execute = func(device, graphicsCommandQueue, onReady) {
			execute(compute, device, res, graphicsCommandQueue, onReady);
		};

		compute.setupCB(cBuff, texSize);
		compute.setupSRVBuff(srvBuff);
		
		onReady(res);
	};

	loadCB(device, func(buff) {
		waiting = waiting - 1;
		cBuff = buff;

		if (waiting == 0) {
			callReady();
		}
	});

	loadSRVBuffs(device, srvBuffSize, srvBuffStride, func(buffs) {
		waiting = waiting - 1;
		srvBuff = buffs;

		print(srvBuff.length);

		if (waiting == 0) {
			callReady();
		}
	});

	loadTex(device, texSize, func(tex) {
		waiting = waiting - 1;
		uavTex = tex;

		if (waiting == 0) {
			callReady();
		}
	});
};

export.prepare = prepareData;