let math = require("math.txt");
let utils = require("utils.txt");

let wnd = api.window();
wnd.create(600, 400);

let dragCrt = func() {
	if (wnd.isAlive() == 0) {
		print("Window closed!");
		wnd = none;
		return;
	}
	wnd.drag();
	timeout(dragCrt, 0);
};
dragCrt();

let device = api.device();
let swapChain = api.swapChain();
let commandQueue = api.commandQueue();

let worlyData = none;
let worlyRenderer = none;

let generalInit = func() {
	device.create();
	commandQueue.create(device);
	swapChain.create(device, wnd, commandQueue);
	print("General Init!");
};

let offset = 0;
let updateUVW = func() {
	return;
	offset = offset + 0.001;
	let tmp = [];
	tmp.push(offset);

	worlyRenderer.constBuff.copyData(tmp);
};

let tryStartRender = func() {
	if (worlyData == none) {
		return;
	}
	if (worlyRenderer == none) {
		return;
	}

	try {
		worlyRenderer.startRender(wnd, swapChain, commandQueue, worlyData, updateUVW);
	}  catch(e) {
		print(e);
	}
};

let requestRenderer = func() {
	let req = require("displayWorly.txt");
	req(device, func(renderer) {
		worlyRenderer = renderer;
		print("Renderer acquired!");
		tryStartRender();
	});
};


let worlyExecute = func() {
	try {
		print("Texture Processing Begin!");
		
		worlyData.execute(device, commandQueue, func() {
			print("Texture Processing End!");
			tryStartRender();
		});

	} catch(e) {
		print(e);
	}
};

let worlyInit = func() {
	let worly = require("worlyCompute.txt");
	worly.prepare(device, 256, func(data) {
		worlyData = data;
		print("Worly Init!");

		worlyExecute();
	});
};

let rend3D = none;

let cam = api.aux.camera();

let offset = 0;

let updateCam = func() {
	offset = offset + 0.01;

	let pos = math.vector3(5 * math.cos(offset), 0, 5 * math.sin(offset));
	let target = math.vector3(0, 0, 0);

	let aspect = wnd.width() / wnd.height();
	cam.setPosition(pos);
	cam.setTarget(target);
	cam.setAspect(aspect);
	cam.setNearPlane(0.1);
	cam.setFarPlane(10000);
	cam.setFOV(60);

	let mat = cam.getMVPMatrix();

	rend3D.constBuff.copyData(mat);
};

let updateCamSafe = func() {
	try {
		updateCam();
	} catch(e) {
		print(e);
	}
};

let startRender3D = func(vertexBuff, indexBuff, instanceBuff) {
	let render3DCL = require("displayCube.txt");
	render3DCL(device, func(rend) {
		rend3D = rend;
		rend3D.startRender(wnd, swapChain, commandQueue, vertexBuff, indexBuff, instanceBuff, updateCamSafe);
	});
};

let cube = require("cube.txt");
let deffShad = none;
let plainCL = require("displayPlain.txt");
let plainRender = none;
try {
	generalInit();

	let dummy = func() {
		let instanceData = [];
		instanceData.push(0);
		instanceData.push(1);
		instanceData.push(0);
		instanceData.push(math.cos(math.PI / 8));
		instanceData.push(-math.sin(math.PI / 8));
		instanceData.push(0);
		instanceData.push(0);
		instanceData.push(1);
		instanceData.push(1);
		instanceData.push(1);

		instanceData.push(0);
		instanceData.push(-1);
		instanceData.push(0);
		instanceData.push(math.cos(math.PI / 8));
		instanceData.push(-math.sin(math.PI / 8));
		instanceData.push(0);
		instanceData.push(0);
		instanceData.push(1);
		instanceData.push(1);
		instanceData.push(1);

		cube(device, instanceData, func(buffer, indexBuffer, instanceBuffer) {
			startRender3D(buffer, indexBuffer, instanceBuffer);
		});
	};

	#worlyInit();
	#requestRenderer();

	let startRender = func() {

		let plain = plainRender(func() {
			let a = 5;
		});
		let rend = func() {
			if (wnd.isAlive() == 0) {
				return;
			}

			deffShad.pipeline.startPass();

			plain();

			deffShad.pipeline.endPass(func() {
				swapChain.present();
				rend();
			});
		};

		rend();
	};

	let defferedShading = require("defferedShading.txt");
	defferedShading(device, swapChain, commandQueue, wnd.width(), wnd.height(), func(obj) {
		deffShad = obj;

		plainCL(device, swapChain, commandQueue, deffShad.pipeline.geometryStart, func(renderFunc) {
			plainRender = renderFunc;
			startRender();
		});
	});
} catch(e) {
	print(e);
}
