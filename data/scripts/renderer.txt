let math = require("math.txt");
let utils = require("utils.txt");
let resources = require("resources/resourceUtils.txt");

let wnd = api.window();
wnd.create(1280, 720);

let device = api.device();
let swapChain = api.swapChain();
let commandQueue = api.commandQueue();
let fence = api.fence();

let generalInit = func() {
	device.create();
	commandQueue.create(device);
	swapChain.create(device, wnd, commandQueue);
	fence.create(device);
	print("General Init!");
};

generalInit();

let cameraInputHandler = api.aux.camera();
let initCamera = func() {
	let pos = math.vector3(0, 2, 0);
	let target = math.vector3(0, 2, 5);

	let aspect = wnd.width() / wnd.height();
	cameraInputHandler.setPosition(pos);
	cameraInputHandler.setTarget(target);
	cameraInputHandler.setAspect(aspect);
	cameraInputHandler.setNearPlane(0.1);
	cameraInputHandler.setFarPlane(10000);
	cameraInputHandler.setFOV(60);

	api.app_context.inputHandler = cameraInputHandler;
};
initCamera();

let renderer = api.renderer.renderer();

renderer.setWindow(wnd);
renderer.setDevice(device);
renderer.setSwapChain(swapChain);
renderer.setCommandQueue(commandQueue);
renderer.setFence(fence);


let clearRT = api.renderer.clearRT();
let clearDS = api.renderer.clearDS();
let unlitPass = api.renderer.unlitPass();
let cloudPass = api.renderer.cloudPass();

renderer.addRenderStage(clearRT);
renderer.addRenderStage(clearDS);
renderer.addRenderStage(unlitPass);
renderer.addRenderStage(cloudPass);

let rendererReady = func() {
	if (renderer.camBuff == none 
		|| renderer.scene == none
		|| renderer.materialRepo == none
		|| renderer.dsTexture == none) {
		return;
	}
	renderer.initRenderStages();
	api.app_context.renderer = renderer;
};

let resources = require("resources/resourceUtils.txt");
let camBB = resources.bufferBuilder();
camBB.upload(1);
camBB.setSize(256);
camBB.setStride(256);

camBB.build(device, func(buff) {
	renderer.setCamBuff(buff);
	rendererReady();
});

let dsTexBB = resources.textureBuilder();
dsTexBB.setWidth(wnd.width());
dsTexBB.setHeight(wnd.height());
dsTexBB.setDS(1);

dsTexBB.build(device, func(tex) {
	renderer.setDSV(tex);
	rendererReady();
});

let materialRepo = api.material.materialRepo();
let simpleUnlit = require("materials/simpleUnlitMat.txt");
let cloudMat = require("materials/cloudMat.txt");


let materialsLoaded = 0;
let setMaterialRepo = func() {
	if (materialsLoaded < 3) {
		return;
	}
	renderer.setMaterialRepo(materialRepo);
	rendererReady();
};

simpleUnlit(device, "shaders/unlit.hlsl", func(mat) {
	let color = [];
	color.push(1);
	color.push(1);
	color.push(0);

	mat.constantBuff.copyData(color);

	materialRepo.addMaterial("default", mat);
	materialsLoaded = setMaterialRepo + 1;
	setMaterialRepo();
});

simpleUnlit(device, "shaders/unlit.hlsl", func(mat) {
	let color = [];
	color.push(1);
	color.push(0);
	color.push(0);

	mat.constantBuff.copyData(color);

	materialRepo.addMaterial("red", mat);
	materialsLoaded = setMaterialRepo + 1;
	setMaterialRepo();
});

cloudMat(device, "shaders/cloudArea.hlsl", func(mat) {
	let area = [];
	area.push(10);
	area.push(0.1);
	
	mat.constantBuff.copyData(area);

	materialRepo.addMaterial("cloudArea", mat);
	materialsLoaded = setMaterialRepo + 1;
	setMaterialRepo();
});

let scene = require("setupScene.txt");

scene(device, func(data) {
	renderer.setScene(data.scene);
	renderer.setMeshRepo(data.meshRepo);
	rendererReady();
});


let prepNoiseTex = require("compute/noiseTexture.txt");

prepNoiseTex(device, 128, "shaders/computeNoise.hlsl", func(comp) {

	let fence = api.fence();
	fence.create(device);

	let prepareForGraphics = func() {
		let prepFE = api.fenceEvent();
		prepFE.create();
		prepFE.wait(fence, 2, func(arg) {
			print("Noise Texture Prepared for Graphics!");
		});
		comp.executePrepareForPS(commandQueue, fence, 2);
	};

	let fe = api.fenceEvent();
	fe.create();
	fe.wait(fence, 1, func(arg) {
		print("Noise Computed!");
		prepareForGraphics();
	});

	comp.populate(128, 128, 128);

	let computeCommandQueue = api.computeCommandQueue();
	computeCommandQueue.create(device);
	comp.executeCompute(computeCommandQueue, fence, 1);

	print("Noise Compute Ready!");
});
