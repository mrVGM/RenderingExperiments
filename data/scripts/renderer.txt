let math = require("math.txt");
let utils = require("utils.txt");
let resources = require("resources/resourceUtils.txt");

let wnd = api.window();
wnd.create(1280, 720);

let device = api.device();
let swapChain = api.swapChain();
let commandQueue = api.commandQueue();
let fence = api.fence();

let generalInit = func() {
	device.create();
	commandQueue.create(device);
	swapChain.create(device, wnd, commandQueue);
	fence.create(device);
	print("General Init!");
};

generalInit();

let renderer = api.renderer.renderer();

renderer.setWindow(wnd);
renderer.setDevice(device);
renderer.setSwapChain(swapChain);
renderer.setCommandQueue(commandQueue);
renderer.setFence(fence);


let rendererReady = func() {
	if (renderer.camBuff == none 
		|| renderer.scene == none
		|| renderer.materialRepo == none) {
		return;
	}
	api.app_context.renderer = renderer;
};

let resources = require("resources/resourceUtils.txt");
let camBB = resources.bufferBuilder();
camBB.upload(1);
camBB.setSize(256);
camBB.setStride(256);

camBB.build(device, func(buff) {
	renderer.setCamBuff(buff);
	rendererReady();
});

let materialRepo = api.material.materialRepo();
let simpleUnlit = require("materials/simpleUnlitMat.txt");

simpleUnlit(device, "shaders/unlit.hlsl", func(mat) {
	materialRepo.addMaterial("default", mat);
	renderer.setMaterialRepo(materialRepo);
	rendererReady();
});


let clearRTRS = api.renderer.clearRTRS();
renderer.addRenderStage(clearRTRS);

renderer.initRenderStages();

let scene = require("setupScene.txt");

scene(device, func(data) {
	renderer.setScene(data.scene);
	renderer.setMeshRepo(data.meshRepo);
	rendererReady();
});