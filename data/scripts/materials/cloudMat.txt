let prepNoiseTex = require("compute/noiseTexture.txt");

let prepNoise = func(device, commandQueue, onReady) {
	let texSize = 256;
	prepNoiseTex(device, texSize, "shaders/computeNoise.hlsl", func(comp) {
		let noiseData = [];
		noiseData.push(texSize);
		noiseData.push(10);
		noiseData.push(4);
		noiseData.push(0.7);
		noiseData.push(2);

		noiseData.push(comp.w1Size);
		noiseData.push(comp.w2Size);
		noiseData.push(comp.w3Size);

		print(comp.w1Size);

		comp.constantBuffer.copyData(noiseData);

		let fence = api.fence();
		fence.create(device);

		let prepareForGraphics = func() {
			let prepFE = api.fenceEvent();
			prepFE.create();
			prepFE.wait(fence, 2, func(arg) {
				print("Noise Texture Prepared for Graphics!");
				onReady(comp);
			});
			comp.executePrepareForPS(commandQueue, fence, 2);
		};

		let fe = api.fenceEvent();
		fe.create();
		fe.wait(fence, 1, func(arg) {
			print("Noise Computed!");
			prepareForGraphics();
		});

		comp.populate(texSize, texSize, texSize);

		let computeCommandQueue = api.computeCommandQueue();
		computeCommandQueue.create(device);
		comp.executeCompute(computeCommandQueue, fence, 1);
		
		print("Noise Compute Ready!");
	});
};

let createMat = func(device, shadersFile, commandQueue, onReady) {
	let shaderCode = readFile(shadersFile);

	let vertexShader = api.vertexShader();
	let pixelShader = api.pixelShader();

	try {
		vertexShader.compile(shaderCode);
		pixelShader.compile(shaderCode);
	} catch(e) {
		print(e);
	}

	let cloudMat = api.material.cloudMat();
	cloudMat.setShaders(vertexShader, pixelShader);

	let resources = require("resources/resourceUtils.txt");
	let bb = resources.bufferBuilder();
	bb.upload(1);
	bb.setSize(256);
	bb.setStride(256);

	let callReady = func() {
		if (cloudMat.constantBuff == none || cloudMat.noiseTexture == none) {
			return;
		}

		onReady(cloudMat);
	};

	bb.build(device, func(buff) {
		cloudMat.setConstantBuff(buff);
		callReady();
	});

	prepNoise(device, commandQueue, func(comp) {
		let noiseTex = comp.texture;

		cloudMat.setNoiseTexture(noiseTex);

		let descriptors = [];
		let texDesc = {};
		texDesc.type = "srv_tex";
		texDesc.texture = noiseTex;
		descriptors.push(texDesc);
		let descHeap = api.descriptorHeap();
		descHeap.create(device, descriptors);
		cloudMat.setNoiseTexture(noiseTex);
		cloudMat.setDescriptionHeap(descHeap);

		callReady();
	});
};

export = createMat;